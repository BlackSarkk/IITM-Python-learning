# Modification type:

1. Mutable types (list, dict, set) → usually modify in place
- list  --> modifies itself	--> .append(), .extend(), .sort(), .reverse()
- dict	--> modifies itself	--> .update(), .clear(), .pop(), .setdefault()
- set	--> modifies itself	--> .add(), .remove(), .discard(), .update()

2. Immutable types (str, tuple, int, float) → always return new objects
- str returns new string	.replace(), .upper(), .strip(), .lower()
- tuple	has no modifying methods	N/A
- int, float are immutable any operation returns new value

3. Functional-style functions (no dot) → return new objects
- sorted(list)	  Returns a new sorted list
- reversed(list)  Returns an iterator (original unchanged)
- sum(list)	      Just computes a value, doesn’t modify


# MANHATTAN DISTANCE

- manHattan Distance between point a, b, c:
    dist_ab = abs(a[0] - b[0]) + abs(a[1] - b[1])
    dist_bc = abs(b[0] - c[0]) + abs(b[1] - c[1])
    total = dist_ab + dist_bc


# min/max:
- max(d, key=d.get)         ==> To get the max-value dict key
- max[list]                 ==> To get the max val from list



# Multiline strings as input:
'''
This is the way to give multiline stirngs as input
'''
- To iterate over the words on multiline stirng input: for i in sting.split()


# takingInput:

- input().strip().split(",")       VALID
- input().split(",").strip()       INVALID coz we need to eliminate all spaces before 




# MAPPING VS FILTERING VS AGGREGATION:

- Aggregation: Combining many values into one final result (sum, count, average, etc.)
             : Summation, Product, Counting, Concatenation, Minimum / Maximum, Updating a variable based on logic
             : If the main intent is to give out only one output or choosing one value from a list
             : Reduction. MANY --> ONE


- Filtering : Selecting some elements based on a condition
            : Choosing only even numbers from a list
            : You choose some items and ignore the rest completely those that don’t meet the condition are not processed at all.
            : If the main intent is to give out only multiple output or choosing many value from a list
            : Reduction. MANY --> MANY

- Mapping : Transforming each element into another form
          : Squaring every number, Converting to string



# any() vs next():
- next() returns the first matching value from the iterator
- eg: next((x for x in [1, 2, 3, 4] if x>2), None) --> returns the first matching value, if nothing matches then returns none

- any() returns true/false