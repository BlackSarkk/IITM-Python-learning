- .remove() : removes the first occurance of the given value from the list or set and return nothing
            : raises error if the value not found
- .pop() : Remove an element at a specific index and return it
         : If no index is provided, it removes and returns the last item. 
         : raises error if the index not found
- .append() : add an element to a list
- .add() : add an element to a set only if the element isn’t already in the set.

- List → Fast creation, slow search
- Set → Slow creation, fast search
- note:  sets can only tell us if the element is present or not, it cant tell what is the first or second element

- import sys => sys.getsizeof(): can be used to check the size of lists, sets..
- import string =>  alpha=string.ascii_uppercase

- A tuple is unchangeable whereis a list, sets can be changed

- .__sizeof__() py is same as sizeof in js 

- we can print string character by index numbers but we cant modify its character as strings are immutables

- Immutable (int, str, tuple) → new object created → outer variable unchanged.  (orignal object change ni hota h )
- Mutable (list, dict, set) → same object modified → change visible everywhere. (orignal object change ho jaata hai)

- Set is mutable, but the values of the set has to be immutable and hashable.. that means we cannot add a list, dictonary etc to a set

- Iterable: list, tuple, set, dict, str, range, bytes, objects with __iter__
- Non-iterable: int, float, complex, bool, None, objects without __iter__

- t = 1, 2, 3 => this will create a tuple  even tho we can do t = (1, 2, 3)
- t = (1,)  # single-element tuple needs a trailing comma
- t = (2)   # this will create a int, not tuple


- t = 1, 2, 3   # packing into a tuple
- x, y, z = t   # unpacking from tuple


- x, y = y, x    #Here py is actually packing it into a variable in the RHS then unpacking it in the LHS

- If the values inside tuple is also immutable then the tuple is consider as hashable, else non-hashable






<!-- ***************************************** -->
<!-- ***************************************** -->

## MUTABLE vs IMMUTABLE 

### 1. Immutable Objects

Examples: int, float, bool, str, tuple, frozenset
Immutable objects cannot be changed after creation.
Any operation that “modifies” them actually creates a new object in memory.
Therefore, their memory location (id) changes after modification.
Assigning one immutable to another just copies the reference, but since they can’t be modified, this is safe.

```py
a = 10
b = a         # binds to same memory location
a += 1        # creates a new int object (11)
print(id(a) == id(b))  # False
```

➡️ Rule: Operations on immutables → new object, new memory address.

### 2. Mutable Objects

Examples: list, dict, set, bytearray
Mutable objects can be changed in place without creating a new object.\
Assigning one mutable to another variable points both names to the same memory location.
Any in-place change (like append, update, etc.) affects all references.

```py
p = [1, 2, 3]
q = p          # binds to same memory location
p.append(4)
print(q)            # [1, 2, 3, 4]
print(id(p) == id(q))  # True
```

➡️ Rule: Operations on mutables → same object, same memory address (unless explicitly copied).

<!-- ***************************************** -->
<!-- ***************************************** -->



### Binding to same memrory location vs Different memory location for lists

- p = [1, 2, 3]
- q = p          # binds to same memory location
- q = p.copy()   # binds to different memory location
- q = p[:]       # binds to different memory location
- q = list(p)    # binds to different memory location


- a, b = (1, 2)              #valid  => a = 1, b = 2
- a, b = (1, 2, 3)           #invalid
- a, b, c, d = (1, 2, 3)     #invalid
- L = [x for x in range(10)] #valid  => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

- Note: prints statement returns "None"


- READ Grpa 1 notes

- sorted(items) returns new list
- items.sort() modifies original list, works only on list   


.insert(index, value)


<!--****************************************  -->
<!--****************************************  -->


# .append() vs .extend()
- append is same as q + [elem]
- "append" adds element as a single entity to the list. eg: [1, 2, 3, [4, 5]]
- append can take both iterable as well as non iterables as an adding element

- extend is same as  q + elem
- "extend" adds each elements individually to the list. eg: [1, 2, 3, 4, 5]
- extend expects the adding element to be an iterable

<!--****************************************  -->
<!--****************************************  -->


- popped-item = items.pop(4)   takes input as indexno if not dict and pops last element if no input, else it takes input as key in dict
- list.remove() takes input as values, 

<!--****************************************  -->
<!--****************************************  -->

- del isnt list specific, It works on names, list elements, slices, dictionary keys, object attributes, etc.
- del x   
- del list[1:3]        Takes index range as input
- del list[3]          Takes index number as input   
- del list[3][4]       
- del dict["age"]      Removes a specific key (and its value).


<!--****************************************  -->
<!--****************************************  -->

# Some set operations:
A.difference_update(B)   ==   (A = A - B)   : modifies set A in place
A.intersection_update(B) ==   (A = A & B)   : modifies set A in place
A.update(B)              ==   (A = A | B)   : modifies set A in place

A.isdisjoint(B)                             : True if A, B share no common element else false
A.issubset(B)                               : True if A is child of B
A.issuperset(B)                             : True if A is parent of B

A.pop()                                     : Removes a random element, it doesnot accepts any input in sets
A.discard(element)                          : Remove the given element from set A, if it exists, else do nothing , no error
A.remove(element)                           : Remove the given element from set A, if it exists, else give out an error

A.symmetric_difference(B)      (A^B)             : Returns a new set containing elements that are uncommon between A and B.
A.symmetric_difference_update(B) == (A = A^B)    : Modifies set A in place to keep only the uncommon elements between A and B.


<!--****************************************  -->
<!--****************************************  -->

- s = {1, 1.0}                ==> len(s) = 1
- coz python pretends both int and float as equal types if their values are same


<!--****************************************  -->
<!--****************************************  -->


# .copy() vs .deepcopy() in a list

## .copy() (Shallow Copy)
- Creates a new outer list, but
- The elements inside (like inner lists, dicts, etc.) are still references to the same objects as in the old list.

## .deepcopy() (Deep Copy)
- Creates a completely new copy, including all inner elements.
- Nothing is shared between the old and new list.
- Changing one will not affect the other.


<!--****************************************  -->
<!--****************************************  -->


# List Comprehension methods:

## Filter if
[ expression  for variable in iterable  if condition ]
eg: L = [x for x in range(10) if x % 2 == 0]

## If–else conditional expression
[ expression_if_true  if condition  else expression_if_false  for variable in iterable ]
eg: L = [1 if i % 2 == 0 else 0 for i in range(10)]



<!--****************************************  -->
<!--****************************************  -->

# Whitespace vs no whitespace characteristics:

## split:
- .split()      : Splits on any whitespace (space, tab, newline, multiple spaces, etc.)  recommended
- .split(" ")   : Splits only on a single space character, if double whiteSpace it will ignore it
- always reutrn a list

### eg:
text = "10   20 30" 
text.split() → ['10', '20', '30'] 
text.split(" ") → ['10', '', '', '20', '30']


## strip:
- .strip()      : All whitespace (space, tab, newline, etc.)  recommended
- .strip()      : " ", \t, \n, \r, etc.

- .strip(" ")   : Only spaces ' '

### eg:
"   hello  ".strip()        # → 'hello'
"\t  hi\n".strip()          # → 'hi'
"   hello  ".strip(" ")     # → 'hello'          ✅ works fine (spaces)
"\t  hi\n".strip(" ")       # → '\t  hi\n'       ❌ tabs/newlines stay



<!--****************************************  -->
<!--****************************************  -->


# reversed() vs sorted() vs .sort():
- Returns    -> a reversed/sorted iterator of the orignal iterable, doesnot modify the orignal iterable

- reversed() -> Works on any iterable that has a defined order (like list, tuple, range, str).
             -> It doesnot returns a list, But you can iterate over it ex:    for x in reversed(list)
             -> It returns a object tho we can convert to a list using :      nList = list(reversed)

- sorted()   -> Works on any iterable, including list, tuple, set, dict, etc.  
             -> Always returns a list no matter what input is

             -> sorted(iterable, *, key=None, reverse=False)
                    iterable → the list, tuple, string, etc. that you want to sort
                    * → means everything after it must be passed as keyword arguments, not positional
                    key → a function that extracts a value to sort by
                    reverse → True/False for descending or ascending


- .sort()    -> Works only on lists only

# Slicing usage: sequence[start:stop:step]
- If an object is a sequence (ordered, indexable, supports len()), you can slice it. eg: Strings, list, tuples
- If it’s unordered (set, dict) or a single value (int, float), slicing will not work. eg: int, float, dict, set



<!--****************************************  -->
<!--****************************************  -->


# Spread operator:
- list: concatenate `some_iterable`, `another_iterable` and `yet_another_iterable` into a list.
         all_iterables = [*some_iterable, *another_iterable, *yet_another_iterable] 

    or   all_iterables = [] 
         all_iterables.extend(some_iterable) 
         all_iterables.extend(another_iterable) ... 

- *  for iterable unpacking (lists, tuples, sets, etc.)
- ** for dictionary unpacking



<!--****************************************  -->
<!--****************************************  -->



# convert everythin to str in a list using map
- newList = map(str, list) 



<!--****************************************  -->
<!--****************************************  -->



# .join()

- This isn't list specific method, its a string method
- It works with any iterables (like list, tuple, set, generator, etc.) as long as every element inside it is a string.
- fails if non-string: like [1, 2, 3]
- It always returns a string

## eg:
" ".join(['a', 'b', 'c'])     # list
" ".join(('a', 'b', 'c'))     # tuple
" ".join({'a', 'b', 'c'})     # set (unordered)
" ".join(x for x in "abc")    # generator